<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title data-i18n="predictions_title">Predictions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="app fade-in">
    <!-- Header -->
    <header class="card">
      <div class="card-header">
        <div>
          <h1 data-i18n="predictions_title">Predictions</h1>
          <p class="muted-text" data-i18n="predictions_subtitle">
            Forecast match vs your past catches at this spot.
          </p>
        </div>
        <button
          id="backBtn"
          class="secondary-btn"
          data-i18n="btn_back_main"
        >
          ‚Üê Back to main
        </button>
      </div>
    </header>

    <!-- Spot summary -->
    <section class="card">
      <div class="card-header">
        <div>
          <h2 id="spotName">‚Ä¶</h2>
          <p id="spotStats" class="muted-text"></p>
        </div>
        <div>
          <label for="speciesFilter" class="muted-text" data-i18n="pred_species_label">
            Species for prediction
          </label>
          <select id="speciesFilter">
            <option value="all" data-i18n="pred_species_all">All species</option>
          </select>
        </div>
      </div>
    </section>

    <!-- Next 3 days -->
    <section class="card">
      <h2 data-i18n="pred_next3_title">Next 3 days</h2>
      <div id="nextDaysContainer" class="prediction-days"></div>
    </section>

    <!-- Hot times tomorrow -->
    <section class="card">
      <h2 data-i18n="pred_hot_title">Hot times tomorrow</h2>
      <div id="hotTimesContainer"></div>
      <p class="muted-text small" data-i18n="pred_hot_note">
        Times are between 1 hour before sunrise and 1 hour after sunset, based on your catches with weather data.
      </p>
    </section>

    <!-- Debug -->
    <section class="card">
      <h2 data-i18n="pred_debug_title">Debug view (why these scores?)</h2>
      <div id="debugContainer" class="muted-text small"></div>
    </section>
  </div>

  <!-- i18n -->
  <script src="i18n.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
    import {
      getFirestore,
      doc,
      getDoc,
      collection,
      query,
      where,
      getDocs,
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1056807867882",
      appId: "1:1056807867882:web:e59ddd8f6353d190080e93",
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const t = window.t || ((k) => k);
    const getCurrentLanguage =
      window.getCurrentLanguage ||
      (() => localStorage.getItem("app_language") || "en");

    const params = new URLSearchParams(window.location.search);
    const spotId = params.get("spotId");

    const backBtn = document.getElementById("backBtn");
    const spotNameEl = document.getElementById("spotName");
    const spotStatsEl = document.getElementById("spotStats");
    const speciesFilterEl = document.getElementById("speciesFilter");
    const nextDaysContainer = document.getElementById("nextDaysContainer");
    const hotTimesContainer = document.getElementById("hotTimesContainer");
    const debugContainer = document.getElementById("debugContainer");

    backBtn.onclick = () => {
      window.location.href = "index.html";
    };

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }

      if (!spotId) {
        spotNameEl.textContent = t("spot_not_found") || "Spot not found";
        return;
      }

      await loadPredictionsPage(user, spotId);
    });

    async function loadPredictionsPage(user, spotId) {
      try {
        const spotRef = doc(db, "spots", spotId);
        const spotSnap = await getDoc(spotRef);
        if (!spotSnap.exists()) {
          spotNameEl.textContent = t("spot_not_found") || "Spot not found";
          return;
        }

        const spot = { id: spotSnap.id, ...spotSnap.data() };
        spotNameEl.textContent = spot.name || (t("spot_no_name") || "Unnamed spot");

        // Load catches for this spot
        const qCatches = query(
          collection(db, "catches"),
          where("userId", "==", user.uid),
          where("spotId", "==", spot.id)
        );
        const snap = await getDocs(qCatches);
        const catches = snap.docs.map((d) => ({ id: d.id, ...d.data() }));

        const withWeather = catches.filter((c) =>
          typeof c.weatherTemp === "number" &&
          typeof c.weatherWindMs === "number" &&
          typeof c.weatherPressure === "number"
        );

        const statsText = formatSpotStats(catches.length, withWeather.length);
        spotStatsEl.textContent = statsText;

        // Species filter
        buildSpeciesFilter(catches);

        // Weather + predictions
        if (
          typeof spot.latitude !== "number" ||
          typeof spot.longitude !== "number"
        ) {
          nextDaysContainer.innerHTML =
            '<p class="muted-text">' +
            (t("pred_weather_location_missing") ||
              "Weather error: location missing.") +
            "</p>";
          hotTimesContainer.innerHTML = "";
          return;
        }

        const forecast = await fetchForecast(spot.latitude, spot.longitude);
        computeAndRenderPredictions(catches, forecast);

        // When species filter changes, recompute
        speciesFilterEl.onchange = () => {
          computeAndRenderPredictions(catches, forecast);
        };
      } catch (err) {
        console.error(err);
        nextDaysContainer.innerHTML =
          '<p class="muted-text">Weather / prediction error.</p>';
      }
    }

    function formatSpotStats(total, withWeather) {
      let template =
        t("pred_spot_stats_template") ||
        "{total} total catches at this spot, {withWeather} with weather data saved.";
      return template
        .replace("{total}", total)
        .replace("{withWeather}", withWeather);
    }

    function buildSpeciesFilter(catches) {
      const set = new Set();
      catches.forEach((c) => {
        if (c.species) set.add(c.species);
      });

      // Clear everything except "all"
      speciesFilterEl.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "all";
      optAll.textContent = t("pred_species_all") || "All species";
      speciesFilterEl.appendChild(optAll);

      Array.from(set)
        .sort()
        .forEach((sp) => {
          const opt = document.createElement("option");
          opt.value = sp;
          opt.textContent = sp;
          speciesFilterEl.appendChild(opt);
        });
    }

    async function fetchForecast(lat, lng) {
      const url =
        "https://api.open-meteo.com/v1/forecast" +
        `?latitude=${lat}&longitude=${lng}` +
        "&current=temperature_2m,wind_speed_10m,weather_code" +
        "&hourly=temperature_2m,wind_speed_10m,pressure_msl" +
        "&daily=sunrise,sunset" +
        "&forecast_days=4&wind_speed_unit=ms&timezone=auto";

      const res = await fetch(url);
      if (!res.ok) {
        throw new Error("Open-Meteo HTTP " + res.status);
      }
      return await res.json();
    }

    /* ---------- Prediction helpers (same logic as index) ---------- */

    function getApproxMoonPhase(date) {
      const lp = 2551443; // seconds in lunar cycle
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14);
      const diff = date.getTime() - knownNewMoon;
      const phase = (diff / 1000) % lp;
      let frac = phase / lp;
      if (frac < 0) frac += 1;
      return frac; // 0..1
    }

    function computePredictionScoreForDay(catches, temp, windMs, press, moon) {
      const usable = catches.filter(
        (c) =>
          typeof c.weatherTemp === "number" &&
          typeof c.weatherWindMs === "number" &&
          typeof c.weatherPressure === "number"
      );
      if (!usable.length) return null;

      const scores = usable.map((c) => {
        let penalty = 0;

        const tempDiff = Math.abs(c.weatherTemp - temp);
        if (tempDiff > 5) penalty += (tempDiff - 5) * 2;

        const windDiff = Math.abs(c.weatherWindMs - windMs);
        if (windDiff > 4) penalty += (windDiff - 4) * 3;

        if (press < 1000) {
          if (c.weatherPressure >= 1000) penalty += 10;
        } else {
          if (c.weatherPressure < 1000) penalty += 10;
        }

        if (typeof c.moonPhase === "number") {
          const moonDiff = Math.abs(c.moonPhase - moon);
          penalty += moonDiff * 40;
        }

        let score = 100 - penalty;
        if (score < 0) score = 0;
        if (score > 100) score = 100;
        return score;
      });

      return scores.reduce((a, b) => a + b, 0) / scores.length;
    }

    function getWeatherIconAndLabel(code) {
      if (code === 0) return { icon: "‚òÄÔ∏è", label: "Clear" };
      if (code === 1) return { icon: "üå§Ô∏è", label: "Mainly clear" };
      if (code === 2) return { icon: "‚õÖ", label: "Partly cloudy" };
      if (code === 3) return { icon: "‚òÅÔ∏è", label: "Overcast" };
      if (code >= 51 && code <= 57) return { icon: "üå¶Ô∏è", label: "Drizzle" };
      if (code >= 61 && code <= 67) return { icon: "üåßÔ∏è", label: "Rain" };
      if (code >= 71 && code <= 77) return { icon: "üå®Ô∏è", label: "Snow" };
      if (code >= 80 && code <= 82) return { icon: "üå¶Ô∏è", label: "Rain showers" };
      if (code >= 85 && code <= 86) return { icon: "üå®Ô∏è", label: "Snow showers" };
      if (code === 95) return { icon: "‚õàÔ∏è", label: "Thunderstorm" };
      if (code === 96 || code === 99)
        return { icon: "‚õàÔ∏è", label: "Thunderstorm with hail" };
      return { icon: "‚ùì", label: "Unknown" };
    }

    function getWeekdayShort(date) {
      const lang = getCurrentLanguage();
      if (lang === "et") {
        // P, E, T, K, N, R, L  (Sun..Sat)
        const map = ["P", "E", "T", "K", "N", "R", "L"];
        return map[date.getDay()];
      } else {
        const map = ["Sun.", "Mon.", "Tues.", "Wed.", "Thurs.", "Fri.", "Sat"];
        return map[date.getDay()];
      }
    }

    function formatDateDotted(date) {
      const dd = String(date.getDate()).padStart(2, "0");
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const yyyy = date.getFullYear();
      return `${dd}.${mm}.${yyyy}`;
    }

    function colorForScore(score) {
      if (score == null) return "#9ca3af";
      if (score >= 70) return "#22c55e"; // good
      if (score >= 40) return "#eab308"; // medium
      return "#f97373"; // poor
    }

    function labelForScore(score) {
      if (score == null) return "";
      if (score >= 70) return t("pred_score_good") || "Good";
      if (score >= 40) return t("pred_score_medium") || "Medium";
      return t("pred_score_poor") || "Poor";
    }

    function computeAndRenderPredictions(allCatches, forecast) {
      const selectedSpecies = speciesFilterEl.value;
      const catches =
        selectedSpecies === "all"
          ? allCatches
          : allCatches.filter((c) => c.species === selectedSpecies);

      const usable = catches.filter(
        (c) =>
          typeof c.weatherTemp === "number" &&
          typeof c.weatherWindMs === "number" &&
          typeof c.weatherPressure === "number"
      );

      if (!usable.length) {
        nextDaysContainer.innerHTML =
          '<p class="muted-text">' +
          (t("pred_no_weather_data") ||
            "No catches with weather data yet for this filter.") +
          "</p>";
        hotTimesContainer.innerHTML = "";
        debugContainer.textContent = "";
        return;
      }

      const hourly = forecast.hourly || {};
      const times = hourly.time || [];
      const temps = hourly.temperature_2m || [];
      const winds = hourly.wind_speed_10m || [];
      const presses = hourly.pressure_msl || [];

      const current = forecast.current || {};
      const { icon, label } = getWeatherIconAndLabel(
        current.weather_code ?? null
      );
      const debugLines = [];

      // ---------- Next 3 days ----------
      nextDaysContainer.innerHTML = "";
      for (let offset = 1; offset <= 3; offset++) {
        const dayDate = new Date();
        dayDate.setDate(dayDate.getDate() + offset);
        const yyyy = dayDate.getFullYear();
        const mm = String(dayDate.getMonth() + 1).padStart(2, "0");
        const dd = String(dayDate.getDate()).padStart(2, "0");
        const dateStr = `${yyyy}-${mm}-${dd}`;

        let idx = times.findIndex((t) => t.startsWith(`${dateStr}T12`));
        if (idx === -1) idx = times.findIndex((t) => t.startsWith(dateStr));
        if (idx === -1) {
          appendDayRow(dayDate, null, null);
          debugLines.push(
            `${formatDateDotted(dayDate)} ‚Äì no forecast index found`
          );
          continue;
        }

        const fTemp = temps[idx];
        const fWind = winds[idx];
        const fPress = presses[idx];
        const fMoon = getApproxMoonPhase(dayDate);

        const score = computePredictionScoreForDay(
          usable,
          fTemp,
          fWind,
          fPress,
          fMoon
        );
        appendDayRow(dayDate, score, { fTemp, fWind, fPress });
        debugLines.push(
          `${formatDateDotted(dayDate)} ‚Äì rawScore=${score?.toFixed(
            2
          )}, forecastPressure=${fPress?.toFixed(1)} hPa`
        );
      }

      // ---------- Hot times tomorrow ----------
      hotTimesContainer.innerHTML = "";

      const daily = forecast.daily || {};
      const sunriseArr = daily.sunrise || [];
      const sunsetArr = daily.sunset || [];

      if (sunriseArr.length < 2 || sunsetArr.length < 2) {
        hotTimesContainer.innerHTML =
          '<p class="muted-text">' +
          (t("pred_hot_no_sunrise") ||
            "No sunrise/sunset data for tomorrow.") +
          "</p>";
      } else {
        const sunrise = new Date(sunriseArr[1]);
        const sunset = new Date(sunsetArr[1]);

        // 1h before sunrise .. 1h after sunset
        const start = new Date(sunrise.getTime() - 60 * 60 * 1000);
        const end = new Date(sunset.getTime() + 60 * 60 * 1000);

        const hotCandidates = [];

        times.forEach((ts, idx) => {
          const d = new Date(ts);
          if (d >= start && d <= end) {
            const temp = temps[idx];
            const wind = winds[idx];
            const press = presses[idx];
            const moon = getApproxMoonPhase(d);
            const score = computePredictionScoreForDay(
              usable,
              temp,
              wind,
              press,
              moon
            );
            if (score != null) {
              hotCandidates.push({ d, score, temp, wind, press });
            }
          }
        });

        hotCandidates.sort((a, b) => b.score - a.score);
        const top = hotCandidates.slice(0, 5);

        if (!top.length) {
          hotTimesContainer.innerHTML =
            '<p class="muted-text">' +
            (t("pred_no_hot_times") ||
              "No good time windows found for tomorrow.") +
            "</p>";
        } else {
          top.forEach((h) => {
            const row = document.createElement("div");
            row.className = "prediction-row";

            const timeStr = h.d.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });

            const scoreColor = colorForScore(h.score);
            const labelText = labelForScore(h.score);

            row.innerHTML = `
              <div class="prediction-main">
                <div>${timeStr}</div>
              </div>
              <div class="prediction-score">
                <span style="color:${scoreColor};font-weight:600;">
                  ${Math.round(h.score)}%
                </span>
                ${
                  labelText
                    ? `<span class="score-pill" style="border-color:${scoreColor};color:${scoreColor};">${labelText}</span>`
                    : ""
                }
              </div>
            `;
            hotTimesContainer.appendChild(row);
          });
        }
      }

      // ---------- Debug ----------
      const nowParts = [];
      if (label) nowParts.push(label);
      if (typeof current.temperature_2m === "number")
        nowParts.push(current.temperature_2m.toFixed(1) + " ¬∞C");
      if (typeof current.wind_speed_10m === "number")
        nowParts.push(current.wind_speed_10m.toFixed(1) + " m/s");

      debugContainer.innerHTML =
        (t("pred_weather_now_label") || "Weather now") +
        `: ${icon || ""} ${nowParts.join(", ")}<br>` +
        debugLines.join("<br>");
    }

    function appendDayRow(dayDate, score, forecastInfo) {
      const row = document.createElement("div");
      row.className = "prediction-row";

      const wd = getWeekdayShort(dayDate);
      const dateText = formatDateDotted(dayDate);
      const labelText = labelForScore(score);
      const color = colorForScore(score);

      row.innerHTML = `
        <div class="prediction-main">
          <div>${wd} ${dateText}</div>
        </div>
        <div class="prediction-score">
          ${
            score == null
              ? `<span class="muted-text">N/A</span>`
              : `<span style="color:${color};font-weight:600;">${Math.round(
                  score
                )}%</span>`
          }
          ${
            labelText && score != null
              ? `<span class="score-pill" style="border-color:${color};color:${color};">${labelText}</span>`
              : ""
          }
        </div>
      `;
      nextDaysContainer.appendChild(row);
    }
  </script>

  <script src="cookie-consent.js"></script>
</body>
</html>
