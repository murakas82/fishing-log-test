<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Predictions ‚Äì Fishing Spot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />

  <style>
    .pred-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(148,163,184,0.25);
    }
    .pred-row:last-child { border-bottom: none; }

    .pred-label { font-weight: 600; }
    .pred-score { font-weight: 700; }

    .tag {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 999px;
      font-size: 0.78rem;
      margin-left: 8px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15, 23, 42, 0.65);
    }
    .tag.good { border-color: rgba(34,197,94,0.6); }
    .tag.med  { border-color: rgba(234,179,8,0.6); }
    .tag.poor { border-color: rgba(248,113,113,0.6); }

    .pred-info {
      margin-top: 8px;
      color: #9ca3af;
      font-size: 0.92rem;
      line-height: 1.35;
    }
    .hot-hour {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(148,163,184,0.2);
    }
    .hot-hour:last-child { border-bottom: none; }
  </style>
</head>

<body>
  <div class="app fade-in">
    <header class="card">
      <div class="card-header">
        <div>
          <h1 data-i18n="pred.title">Predictions</h1>
          <p class="muted-text" data-i18n="pred.subtitle">
            Forecast match vs your past catches at this spot.
          </p>
        </div>
        <button class="secondary-btn btn-back-main" id="backToSpotBtn" data-i18n="common.backToMain">
          ‚Üê Back to main
        </button>
      </div>
    </header>

    <div class="card">
      <div class="grid-2">
        <div>
          <h2 id="spotNameHeading" style="margin:0 0 4px;" data-i18n="pred.loadingSpot">Loading spot‚Ä¶</h2>
          <p id="spotDesc" class="pred-info" style="margin:0;" data-i18n="pred.fetchingData">Fetching data‚Ä¶</p>
        </div>
      </div>
    </div>

    <div class="card" id="predictionsCard" style="display:none;">
      <h2 data-i18n="pred.next3Days">Next 3 days</h2>
      <div id="predictionsList"></div>
      <p class="pred-info" id="predSummary"></p>
    </div>

    <div class="card" id="hotTimesCard" style="display:none;">
      <h2 data-i18n="pred.hotTimesTomorrow">Hot times tomorrow</h2>
      <div id="hotTimesList"></div>
      <p class="pred-info" id="hotTimesNote" data-i18n="pred.hotTimesExplain">
        Times are between 1 hour before sunrise and 1 hour after sunset, based on your catches with weather data.
      </p>
    </div>

    <div class="card" id="debugCard" style="display:none;">
      <h2 data-i18n="pred.debugTitle">Debug view (why these scores?)</h2>
      <p class="pred-info" id="debugInfo"></p>
      <p class="pred-info" id="weatherNowInfo"></p>
    </div>
  </div>

  <script src="translations.js"></script>

  <script type="module">
    import { initializeApp }
      from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
    import {
      getFirestore,
      doc, getDoc,
      collection, getDocs,
      query, where
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    import { computeDayScoreFromForecast, computeHotHoursFromForecast } from "./predictions-core.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1056807867882",
      appId: "1:1056807867882:web:e59ddd8f6353d190080e93"
    };

    const app  = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    const i18n = window.fishingLogI18n;
    const t = (k) => (i18n && typeof i18n.t === "function") ? i18n.t(k) : k;

    const spotNameHeading = document.getElementById("spotNameHeading");
    const spotDesc        = document.getElementById("spotDesc");
    const predictionsCard = document.getElementById("predictionsCard");
    const predictionsList = document.getElementById("predictionsList");
    const predSummary     = document.getElementById("predSummary");
    const hotTimesCard    = document.getElementById("hotTimesCard");
    const hotTimesList    = document.getElementById("hotTimesList");
    const debugCard       = document.getElementById("debugCard");
    const debugInfo       = document.getElementById("debugInfo");
    const weatherNowInfo  = document.getElementById("weatherNowInfo");
    const backToSpotBtn   = document.getElementById("backToSpotBtn");

    function reapplyTranslations() {
      if (i18n && typeof i18n.applyTranslations === "function") i18n.applyTranslations();
    }

    function getSpotIdFromUrl() {
      const p = new URLSearchParams(window.location.search);
      return p.get("spotId");
    }

    function formatDateLabel(dateObj) {
      // Thu. 18.12.2025
      const weekdays = ["Sun.", "Mon.", "Tue.", "Wed.", "Thu.", "Fri.", "Sat."];
      const wd = weekdays[dateObj.getDay()];
      const dd = String(dateObj.getDate()).padStart(2, "0");
      const mm = String(dateObj.getMonth() + 1).padStart(2, "0");
      const yyyy = dateObj.getFullYear();
      return `${wd} ${dd}.${mm}.${yyyy}`;
    }

    function getWeatherIconAndLabel(code) {
      if (code === 0)  return { icon: "‚òÄÔ∏è", label: t("home.weatherClear") };
      if (code === 1)  return { icon: "üå§Ô∏è", label: t("home.weatherMainlyClear") };
      if (code === 2)  return { icon: "‚õÖ",  label: t("home.weatherPartlyCloudy") };
      if (code === 3)  return { icon: "‚òÅÔ∏è",  label: t("home.weatherOvercast") };

      if (code === 45 || code === 48) return { icon: "üå´Ô∏è", label: t("pred.weatherFog") };

      if ([51,53,55,56,57].includes(code)) return { icon: "üå¶Ô∏è", label: t("home.weatherDrizzle") };
      if ([61,63,65,66,67].includes(code)) return { icon: "üåßÔ∏è", label: t("home.weatherRain") };
      if ([71,73,75,77,85,86].includes(code)) return { icon: "üå®Ô∏è", label: t("home.weatherSnow") };
      if ([80,81,82].includes(code)) return { icon: "üå¶Ô∏è", label: t("home.weatherRainShowers") };
      if ([95].includes(code)) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstorm") };
      if ([96,99].includes(code)) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstormHail") };

      return { icon: "‚ùî", label: t("home.weatherUnknown") };
    }

    async function loadSpotAndCatches(user, spotId) {
      const spotRef = doc(db, "users", user.uid, "spots", spotId);
      const spotSnap = await getDoc(spotRef);

      if (!spotSnap.exists()) return { spot: null, spotCatches: [] };

      const spot = { id: spotSnap.id, ...spotSnap.data() };

      const catchesRef = collection(db, "users", user.uid, "catches");
      const qC = query(catchesRef, where("spotId", "==", spotId));
      const catchSnap = await getDocs(qC);

      const spotCatches = [];
      catchSnap.forEach(docu => {
        const d = docu.data();
        spotCatches.push({
          id: docu.id,
          ...d,
          weatherTemp: d.weatherTemp,
          weatherWindMs: d.weatherWindMs,
          weatherPressure: d.weatherPressure,
          weatherWindDirDeg: d.weatherWindDirDeg,
          moonPhase: d.moonPhase
        });
      });

      return { spot, spotCatches };
    }

    async function computeSpotWeatherAndPredictions(lat, lng, spotCatches) {
      let weatherNowText = t("pred.weatherFailedToLoad");
      const predictions = [];
      let hotHoursTomorrow = [];

      const url =
        `https://api.open-meteo.com/v1/forecast` +
        `?latitude=${lat}&longitude=${lng}` +
        `&current=temperature_2m,wind_speed_10m,wind_direction_10m,weather_code,pressure_msl,cloudcover` +
        `&hourly=temperature_2m,wind_speed_10m,wind_direction_10m,pressure_msl,cloudcover` +
        `&daily=sunrise,sunset` +
        `&forecast_days=4` +
        `&wind_speed_unit=ms` +
        `&timezone=auto`;

      const res = await fetch(url);
      if (!res.ok) throw new Error("Open-Meteo HTTP " + res.status);
      const data = await res.json();

      // ---- Current weather ----
      const cur = data.current || {};
      const tempNow =
        typeof cur.temperature_2m === "number" ? cur.temperature_2m : null;
      const windMsNow =
        typeof cur.wind_speed_10m === "number" ? cur.wind_speed_10m : null;
      const codeNow = cur.weather_code;

      const { icon, label } = getWeatherIconAndLabel(codeNow);
      const wParts = [];
      if (label) wParts.push(label);
      if (tempNow != null) wParts.push(`${tempNow.toFixed(1)} ${t("home.unitCelsius")}`);
      if (windMsNow != null) wParts.push(`${t("home.wind")} ${windMsNow.toFixed(1)} ${t("home.unitMetersPerSecond")}`);

      weatherNowText = wParts.length
        ? `${t("home.weatherNow")}: ${icon} ${wParts.join(", ")}`
        : t("pred.weatherNotAvailable");

      // ---- Next 3 days ----
      for (let offset = 1; offset <= 3; offset++) {
        const d = new Date();
        d.setDate(d.getDate() + offset);
        const score = computeDayScoreFromForecast(data, spotCatches, offset);
        predictions.push({
          score: (typeof score === "number") ? score : null,
          dateLabel: formatDateLabel(d)
        });
      }

      // ---- Hot times tomorrow (daylight window) ----
      const hot = computeHotHoursFromForecast(data, spotCatches, 1);
      hotHoursTomorrow = hot.map(r => ({
        label: r.dateObj.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }),
        score: r.score
      }));

      return { weatherNowText, predictions, hotHoursTomorrow };
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }

      const spotId = getSpotIdFromUrl();
      if (!spotId) {
        spotNameHeading.textContent = t("pred.noSpotSelected");
        spotDesc.textContent = t("pred.missingSpotId");
        debugCard.style.display = "block";
        debugInfo.textContent = t("pred.missingSpotId");
        return;
      }

      spotDesc.textContent = t("pred.loadingCatchesAndForecast");

      try {
        const { spot, spotCatches } = await loadSpotAndCatches(user, spotId);

        if (!spot) {
          spotNameHeading.textContent = t("pred.spotNotFound");
          spotDesc.textContent = t("pred.unableToLoadSpot");
          debugCard.style.display = "block";
          debugInfo.textContent = t("pred.spotNotFound");
          return;
        }

        const name = spot.name || t("spotPage.unnamedSpot");
        spotNameHeading.textContent = name;

        const usableCount = spotCatches.filter(c =>
          typeof c.weatherTemp === "number" &&
          typeof c.weatherWindMs === "number" &&
          typeof c.weatherPressure === "number"
        ).length;

        spotDesc.textContent = t("pred.spotCatchSummary")
          .replace("{total}", String(spotCatches.length))
          .replace("{withWeather}", String(usableCount));

        const lat = spot.lat;
        const lng = spot.lng;

        if (typeof lat !== "number" || typeof lng !== "number") {
          predictionsCard.style.display = "none";
          hotTimesCard.style.display    = "none";
          debugCard.style.display       = "block";
          debugInfo.textContent         = t("pred.noGpsNoPrediction");
          return;
        }

        const { weatherNowText, predictions, hotHoursTomorrow } =
          await computeSpotWeatherAndPredictions(lat, lng, spotCatches);

        weatherNowInfo.textContent = weatherNowText;

        const anyForecast = predictions.some(p => typeof p.score === "number");
        if (anyForecast) {
          predictionsCard.style.display = "block";
          hotTimesCard.style.display    = (hotHoursTomorrow && hotHoursTomorrow.length) ? "block" : "none";
          debugCard.style.display       = "block";
        } else {
          predictionsCard.style.display = "none";
          hotTimesCard.style.display    = "none";
          debugCard.style.display       = "block";
        }

        renderPredictions(predictions, usableCount);
        renderHotHours(hotHoursTomorrow);

      } catch (e) {
        predictionsCard.style.display = "none";
        hotTimesCard.style.display    = "none";
        debugCard.style.display       = "block";
        debugInfo.textContent         = t("pred.failedToCompute");
      }
    });

    function renderPredictions(predictions, usableCount) {
      predictionsList.innerHTML = "";

      if (!predictions.length) {
        predictionsList.innerHTML = `<p class="pred-info">${t("pred.noForecastData")}</p>`;
        predSummary.textContent = "";
        return;
      }

      let sumScores = 0;
      let countScores = 0;

      predictions.forEach(p => {
        const row = document.createElement("div");
        row.className = "pred-row";

        const left = document.createElement("div");
        left.className = "pred-label";
        left.textContent = p.dateLabel;

        const right = document.createElement("div");
        right.className = "pred-score";

        if (typeof p.score !== "number") {
          right.textContent = t("home.na");
          const tag = document.createElement("span");
          tag.className = "tag";
          tag.textContent = t("pred.tagNoData");
          left.appendChild(tag);
        } else {
          right.textContent = `${p.score.toFixed(0)}%`;
          sumScores += p.score;
          countScores++;

          let tagClass = "poor";
          let tagText  = t("pred.tagPoor");
          if (p.score >= 70) { tagClass = "good"; tagText = t("pred.tagGood"); }
          else if (p.score >= 40) { tagClass = "med"; tagText = t("pred.tagMedium"); }

          const tag = document.createElement("span");
          tag.className = `tag ${tagClass}`;
          tag.textContent = tagText;
          left.appendChild(tag);
        }

        row.appendChild(left);
        row.appendChild(right);
        predictionsList.appendChild(row);
      });

      if (countScores > 0) {
        const avg = sumScores / countScores;
        predSummary.textContent = t("pred.avgScoreSummary")
          .replace("{avg}", avg.toFixed(0))
          .replace("{usable}", String(usableCount));
      } else {
        predSummary.textContent = t("pred.noUsableCatchesYet");
      }
    }

    function renderHotHours(hotHours) {
      if (!hotHours || !hotHours.length) {
        hotTimesCard.style.display = "none";
        return;
      }
      hotTimesList.innerHTML = "";

      hotHours.forEach(h => {
        const row = document.createElement("div");
        row.className = "hot-hour";

        const left = document.createElement("div");
        left.className = "pred-label";
        left.textContent = h.label;

        const right = document.createElement("div");
        right.className = "pred-score";
        right.textContent = `${h.score.toFixed(0)}%`;

        row.appendChild(left);
        row.appendChild(right);
        hotTimesList.appendChild(row);
      });
    }

    backToSpotBtn.onclick = () => {
      window.location.href = "index.html";
    };

    reapplyTranslations();
  </script>
</body>
</html>
