<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Add catch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="app fade-in">
    <header class="card">
      <div class="card-header">
        <div>
          <h1 data-i18n="catch.title">Add catch</h1>
          <p class="muted-text" data-i18n="catch.subtitle">
            Log a new catch with spot, weight, weather &amp; notes.
          </p>
        </div>
        <div>
          <button class="secondary-btn btn-back-main" id="backBtn" data-i18n="common.backToMain">
            ‚Üê Back to main
          </button>
        </div>
      </div>
    </header>

    <div class="card">
      <div class="card-header">
        <div class="muted-text">
          <span data-i18n="common.loggedInAs">Logged in as ‚Ä¶</span>
          <span id="loggedInAs">‚Ä¶</span>
        </div>
      </div>

      <div class="form-grid">
        <div class="form-field">
          <label for="species" data-i18n="catch.speciesLabel">Species</label>
          <input
            id="species"
            type="text"
            placeholder="pike, perch, etc."
            data-i18n-placeholder="catch.speciesPlaceholder"
            list="speciesDatalist"
            autocomplete="off"
          />
          <datalist id="speciesDatalist"></datalist>
        </div>

        <div class="form-field">
          <label for="weightKg" data-i18n="catch.weightLabel">Weight (kg)</label>
          <input id="weightKg" type="number" step="0.01" />
        </div>

        <div class="form-field">
          <label for="spotSelect" data-i18n="catch.spotLabel">Fishing spot (required)</label>
          <select id="spotSelect"></select>
        </div>

        <div class="form-field">
          <label for="lure" data-i18n="catch.lureLabel">Lure</label>
          <input
            id="lure"
            type="text"
            placeholder="Spinner, jig, worm‚Ä¶"
            data-i18n-placeholder="catch.lurePlaceholder"
            autocomplete="off"
          />
        </div>

        <div class="form-field">
          <label for="depth" data-i18n="catch.depthLabel">Water depth (m)</label>
          <input id="depth" type="number" step="0.1" />
        </div>

        <div class="form-field">
          <label for="waterTemp" data-i18n="catch.waterTempLabel">Water temperature (¬∞C)</label>
          <input id="waterTemp" type="number" step="0.1" />
        </div>

        <div class="form-field">
          <label for="latitude" data-i18n="catch.latLabel">Latitude (auto from spot or GPS)</label>
          <input id="latitude" type="number" step="0.000001" />
        </div>

        <div class="form-field">
          <label for="longitude" data-i18n="catch.lonLabel">Longitude (auto from spot or GPS)</label>
          <input id="longitude" type="number" step="0.000001" />
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
        <button class="secondary-btn" id="useLocationBtn" data-i18n="common.useMyLocation">
          Use my location
        </button>
      </div>

      <p id="weatherNow" class="muted-text" style="margin-top:8px;">
        <span data-i18n="home.weatherNow">Weather now</span>:
        <span data-i18n="catch.weatherNotLoadedInline">(not loaded yet)</span>
      </p>

      <div class="form-field" style="margin-top:12px;">
        <label for="notes" data-i18n="catch.notesLabel">Notes</label>
        <textarea
          id="notes"
          rows="3"
          placeholder="Weather, behavior, etc."
          data-i18n-placeholder="catch.notesPlaceholder"
        ></textarea>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:16px;">
        <button class="primary-btn" id="saveCatchBtn" data-i18n="catch.saveButton">Save catch</button>
      </div>

      <p id="statusMsg" class="muted-text" style="margin-top:10px;"></p>
    </div>
  </div>

  <!-- i18n (load once) -->
  <script src="translations.js"></script>

  <script type="module">
    import { initializeApp }
      from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      query,
      where
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1056807867882",
      appId: "1:1056807867882:web:e59ddd8f6353d190080e93"
    };

    const app  = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // i18n helpers
    const i18n = window.fishingLogI18n;
    const t = (key) => (i18n && typeof i18n.t === "function") ? i18n.t(key) : key;
    function reapplyTranslations() {
      if (i18n && typeof i18n.applyTranslations === "function") i18n.applyTranslations();
    }

    const backBtn        = document.getElementById("backBtn");
    const loggedInAsEl   = document.getElementById("loggedInAs");
    const speciesEl      = document.getElementById("species");
    const speciesDatalist= document.getElementById("speciesDatalist");
    const weightEl       = document.getElementById("weightKg");
    const spotSelectEl   = document.getElementById("spotSelect");
    const lureEl         = document.getElementById("lure");
    const depthEl        = document.getElementById("depth");
    const waterTempEl    = document.getElementById("waterTemp");
    const latEl          = document.getElementById("latitude");
    const lngEl          = document.getElementById("longitude");
    const useLocationBtn = document.getElementById("useLocationBtn");
    const saveCatchBtn   = document.getElementById("saveCatchBtn");
    const weatherNowEl   = document.getElementById("weatherNow");
    const statusMsg      = document.getElementById("statusMsg");
    const notesEl        = document.getElementById("notes");

    const params    = new URLSearchParams(window.location.search);
    const urlSpotId = params.get("spotId");
    const fromParam = params.get("from") || "main"; // "spot" or "main"

    let currentUser = null;
    let spots = [];
    let latestWeather = null; // store for saving

    backBtn.onclick = () => {
      window.location.href = "index.html";
    };

    /* ---------------- Normalization helpers ---------------- */

    // Title Case per-word, trims, collapses spaces.
    function normalizeTitleCase(input) {
      if (!input) return "";
      return input
        .trim()
        .toLowerCase()
        .replace(/\s+/g, " ")
        .replace(/(^|\s)\S/g, (c) => c.toUpperCase());
    }

    function normalizeSpeciesName(input) {
      return normalizeTitleCase(input);
    }

    function normalizeLureName(input) {
      return normalizeTitleCase(input);
    }

    // Create a deterministic key for "probable duplicates"
    // Same user + same spot + same date + same species + same weight(2dp) + same lure
    function buildDuplicateKey(uid, spotId, speciesNorm, weightFixed2, lureNorm, timestampMs) {
      const d = new Date(timestampMs);
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const dateStr = `${yyyy}-${mm}-${dd}`;
      return `${uid}|${spotId}|${dateStr}|${speciesNorm}|${weightFixed2}|${lureNorm || "-"}`;
    }

    /* ---------------- Weather helpers ---------------- */

    function getApproxMoonPhase(date) {
      const lp = 2551443;
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14);
      const diff = date.getTime() - knownNewMoon;
      const phase = (diff / 1000) % lp;
      let frac = phase / lp;
      if (frac < 0) frac += 1;
      return frac;
    }

    function getWeatherIconAndLabel(code) {
      if (code === 0)  return { icon: "‚òÄÔ∏è", label: t("home.weatherClear") };
      if (code === 1)  return { icon: "üå§Ô∏è", label: t("home.weatherMainlyClear") };
      if (code === 2)  return { icon: "‚õÖ",  label: t("home.weatherPartlyCloudy") };
      if (code === 3)  return { icon: "‚òÅÔ∏è", label: t("home.weatherOvercast") };
      if (code >= 51 && code <= 57) return { icon: "üå¶Ô∏è", label: t("home.weatherDrizzle") };
      if (code >= 61 && code <= 67) return { icon: "üåßÔ∏è", label: t("home.weatherRain") };
      if (code >= 71 && code <= 77) return { icon: "üå®Ô∏è", label: t("home.weatherSnow") };
      if (code >= 80 && code <= 82) return { icon: "üå¶Ô∏è", label: t("home.weatherRainShowers") };
      if (code >= 85 && code <= 86) return { icon: "üå®Ô∏è", label: t("home.weatherSnowShowers") };
      if (code === 95) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstorm") };
      if (code === 96 || code === 99) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstormHail") };
      return { icon: "‚ùì", label: t("home.weatherUnknown") };
    }

    function setWeatherInlineStatus(i18nKey, fallbackText) {
      weatherNowEl.innerHTML =
        `<span data-i18n="home.weatherNow">Weather now</span>: ` +
        `<span data-i18n="${i18nKey}">${fallbackText}</span>`;
      reapplyTranslations();
    }

    async function fetchCurrentWeather(lat, lng) {
      try {
        setWeatherInlineStatus("home.loading", "loading‚Ä¶");

        const url =
          `https://api.open-meteo.com/v1/forecast` +
          `?latitude=${lat}&longitude=${lng}` +
          `&current=temperature_2m,wind_speed_10m,weather_code,pressure_msl` +
          `&timezone=auto&wind_speed_unit=ms`;

        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        const cur = data.current || {};
        const temp   = cur.temperature_2m;
        const windMs = cur.wind_speed_10m;
        const press  = cur.pressure_msl;
        const code   = cur.weather_code;

        const { icon, label } = getWeatherIconAndLabel(code);

        const parts = [];
        if (label) parts.push(label);
        if (typeof temp === "number") parts.push(`${temp.toFixed(1)} ${t("home.unitCelsius")}`);
        if (typeof windMs === "number") parts.push(`${t("home.wind")} ${windMs.toFixed(1)} ${t("home.unitMetersPerSecond")}`);

        weatherNowEl.innerHTML =
          `<span data-i18n="home.weatherNow">Weather now</span>: ` +
          `${icon} ${parts.join(", ")}`;
        reapplyTranslations();

        latestWeather = {
          weatherTemp: temp,
          weatherWindMs: windMs,
          weatherPressure: press,
          weatherCode: code,
          weatherCondition: label,
          weatherDescription: `${label || t("home.weatherUnknown")}, ` +
            `${typeof temp === "number" ? temp.toFixed(1) + " " + t("home.unitCelsius") : t("home.na")}, ` +
            `${t("home.wind")} ${typeof windMs === "number" ? windMs.toFixed(1) : t("home.na")} ${t("home.unitMetersPerSecond")}`,
          moonPhase: getApproxMoonPhase(new Date())
        };
      } catch (err) {
        setWeatherInlineStatus("home.failedToLoad", "failed to load.");
        latestWeather = null;
      }
    }

    /* ---------------- Auto-suggest species from past catches ---------------- */

    async function loadSpeciesSuggestions(uid) {
      // query only by userId; small dataset per user; avoids composite-index issues
      const snap = await getDocs(query(collection(db, "catches"), where("userId", "==", uid)));

      const counts = new Map();
      snap.forEach(d => {
        const data = d.data() || {};
        const s = normalizeSpeciesName(data.species || "");
        if (!s) return;
        counts.set(s, (counts.get(s) || 0) + 1);
      });

      const list = Array.from(counts.entries())
        .sort((a, b) => {
          // sort by usage desc, then alpha
          if (b[1] !== a[1]) return b[1] - a[1];
          return a[0].localeCompare(b[0]);
        })
        .slice(0, 30)
        .map(([name]) => name);

      speciesDatalist.innerHTML = list.map(v => `<option value="${v}"></option>`).join("");
    }

    // Normalize species on blur (so it becomes ‚ÄúHaug‚Äù immediately in the input)
    speciesEl.addEventListener("blur", () => {
      const norm = normalizeSpeciesName(speciesEl.value);
      if (norm) speciesEl.value = norm;
    });

    // Normalize lure on blur
    lureEl.addEventListener("blur", () => {
      const norm = normalizeLureName(lureEl.value);
      if (norm) lureEl.value = norm;
    });

    /* ---------------- Spots ---------------- */

    function renderSpotOptions() {
      if (!spots.length) {
        spotSelectEl.innerHTML = `<option value="">${t("catch.noSpotsYetOption")}</option>`;
        spotSelectEl.disabled = true;
        return;
      }

      spotSelectEl.disabled = false;

      const chooseText = t("catch.chooseSpotOption");
      const unnamedText = t("catch.unnamedSpotOption");

      spotSelectEl.innerHTML =
        `<option value="">${chooseText}</option>` +
        spots.map(s =>
          `<option value="${s.id}">${(s.name || unnamedText)}</option>`
        ).join("");

      if (urlSpotId) spotSelectEl.value = urlSpotId;
      handleSpotChange();
    }

    async function loadSpotsForUser(user) {
      const q = query(collection(db, "spots"), where("userId", "==", user.uid));
      const snap = await getDocs(q);
      spots = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      spots.sort((a,b) => (a.name || "").localeCompare(b.name || ""));
      renderSpotOptions();
    }

    function handleSpotChange() {
      const spotId = spotSelectEl.value;
      const spot = spots.find(s => s.id === spotId);

      if (spot && typeof spot.latitude === "number" && typeof spot.longitude === "number") {
        latEl.value = spot.latitude.toFixed(6);
        lngEl.value = spot.longitude.toFixed(6);
        fetchCurrentWeather(spot.latitude, spot.longitude);
      } else {
        weatherNowEl.innerHTML =
          `<span data-i18n="home.weatherNow">Weather now</span>: ` +
          `<span data-i18n="catch.weatherNotLoadedInline">(not loaded yet)</span>`;
        latestWeather = null;
        reapplyTranslations();
      }
    }

    spotSelectEl.addEventListener("change", handleSpotChange);

    /* ---------------- Geolocation ---------------- */

    useLocationBtn.onclick = () => {
      if (!navigator.geolocation) {
        statusMsg.textContent = t("catch.geoNotAvailable");
        return;
      }
      statusMsg.textContent = t("catch.gettingLocation");
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          latEl.value = latitude.toFixed(6);
          lngEl.value = longitude.toFixed(6);
          statusMsg.textContent = "";
          fetchCurrentWeather(latitude, longitude);
        },
        (err) => {
          statusMsg.textContent = `${t("catch.couldNotGetLocation")} ${err.message}`;
        }
      );
    };

    /* ---------------- Duplicate prevention ---------------- */

    async function catchExistsByKey(dupKey) {
      // Single-field equality query (no composite index needed)
      const snap = await getDocs(query(collection(db, "catches"), where("duplicateKey", "==", dupKey)));
      return !snap.empty;
    }

    /* ---------------- Save catch ---------------- */

    async function saveCatch() {
      statusMsg.textContent = "";

      if (!currentUser) {
        statusMsg.textContent = t("catch.mustBeLoggedIn");
        return;
      }

      // Normalize species/lure
      const speciesNorm = normalizeSpeciesName(speciesEl.value || "");
      const lureNorm    = normalizeLureName(lureEl.value || "");

      if (speciesNorm) speciesEl.value = speciesNorm;
      if (lureNorm) lureEl.value = lureNorm;

      const species = speciesNorm || t("catch.defaultSpecies");

      const weight = parseFloat(weightEl.value);
      const spotId = spotSelectEl.value;

      if (!spotId) {
        statusMsg.textContent = t("catch.chooseSpotRequired");
        return;
      }
      if (isNaN(weight) || weight <= 0) {
        statusMsg.textContent = t("catch.enterValidWeight");
        return;
      }

      const depth = parseFloat(depthEl.value);
      const waterTemp = parseFloat(waterTempEl.value);
      const lat = parseFloat(latEl.value);
      const lng = parseFloat(lngEl.value);
      const notes = (notesEl.value || "").trim();

      const ts = Date.now();
      const weightFixed2 = weight.toFixed(2);

      const duplicateKey = buildDuplicateKey(
        currentUser.uid,
        spotId,
        species,
        weightFixed2,
        lureNorm,
        ts
      );

      // Duplicate check
      try {
        const exists = await catchExistsByKey(duplicateKey);
        if (exists) {
          // Ask user if they really want to save a duplicate
          const msg = t("catch.confirmDuplicateSave");
          const ok = confirm(msg !== "catch.confirmDuplicateSave"
            ? msg
            : "This looks like a duplicate catch (same spot, same day, same species/weight/lure). Save anyway?"
          );
          if (!ok) {
            statusMsg.textContent = t("catch.duplicateBlocked");
            return;
          }
        }
      } catch (err) {
        // If duplicate check fails, we still allow saving (safer than blocking),
        // but show an informational status.
        console.warn("Duplicate check failed:", err);
      }

      const catchDoc = {
        userId: currentUser.uid,
        species,
        weightKg: parseFloat(weightFixed2),
        spotId,
        spotName: (spots.find(s => s.id === spotId)?.name) || "",
        lure: lureNorm,
        depth: isNaN(depth) ? null : depth,
        temperature: isNaN(waterTemp) ? null : waterTemp,
        latitude: isNaN(lat) ? null : lat,
        longitude: isNaN(lng) ? null : lng,
        notes,
        timestamp: ts,
        duplicateKey
      };

      if (latestWeather) {
        Object.assign(catchDoc, {
          weatherTemp: latestWeather.weatherTemp,
          weatherWindMs: latestWeather.weatherWindMs,
          weatherPressure: latestWeather.weatherPressure,
          weatherCode: latestWeather.weatherCode,
          weatherCondition: latestWeather.weatherCondition,
          weatherDescription: latestWeather.weatherDescription,
          moonPhase: latestWeather.moonPhase
        });
      }

      saveCatchBtn.disabled = true;
      saveCatchBtn.textContent = t("catch.saving");

      try {
        await addDoc(collection(db, "catches"), catchDoc);

        statusMsg.textContent = t("catch.savedRedirecting");

        if (fromParam === "spot" && spotId) {
          window.location.href = `spot.html?id=${encodeURIComponent(spotId)}`;
        } else {
          window.location.href = "index.html";
        }
      } catch (err) {
        statusMsg.textContent = `${t("catch.errorSaving")} ${(err.message || err)}`;
        saveCatchBtn.disabled = false;
        saveCatchBtn.textContent = t("catch.saveButton");
        reapplyTranslations();
      }
    }

    saveCatchBtn.onclick = saveCatch;

    /* ---------------- Auth ---------------- */

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }
      currentUser = user;
      loggedInAsEl.textContent = user.email || t("spotAdd.unknownUser");

      await loadSpotsForUser(user);
      await loadSpeciesSuggestions(user.uid);

      reapplyTranslations();
    });

    // initial translate
    reapplyTranslations();
  </script>
</body>
</html>
