<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My fishing spots ‚Äì map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    #map {
      width: 100%;
      height: 420px;
      border-radius: 16px;
      overflow: hidden;
      margin-top: 10px;
    }

    /* Move Leaflet zoom controls to top-right like in add-spot */
    .leaflet-top.leaflet-left {
      right: 16px !important;
      left: auto !important;
      top: 16px !important;
    }
  </style>
</head>
<body>
  <div class="app fade-in">
    <header class="card">
      <div class="card-header">
        <div>
          <h1 data-i18n="spotsMap.title">My fishing spots ‚Äì map</h1>
          <p class="muted-text" data-i18n="spotsMap.subtitle">
            See all your spots on an interactive map with live weather &amp; predictions.
          </p>
        </div>
        <button class="secondary-btn btn-back-main" id="backBtn" data-i18n="common.backToMain">
          ‚Üê Back to main
        </button>
      </div>
    </header>

    <div class="card">
      <h2 data-i18n="spotsMap.overview">Spots overview</h2>
      <div id="map"></div>

      <!-- Legend: keep colored dots; translate labels -->
      <p class="muted-text" style="margin-top:10px;">
        ‚Ä¢ <span data-i18n="spotsMap.legendMarkerColor">Marker color (tomorrow)</span>:
        <span style="color:#22c55e;">‚óè</span> <span data-i18n="spotsMap.legendGood">good</span> (‚â•70%),
        <span style="color:#facc15;">‚óè</span> <span data-i18n="spotsMap.legendMedium">medium</span> (40‚Äì69%),
        <span style="color:#ef4444;">‚óè</span> <span data-i18n="spotsMap.legendPoor">poor</span> (&lt;40%).<br/>
        ‚Ä¢ <span data-i18n="spotsMap.legendPopupShows">Popup shows live weather now and predictions for the next 3 days.</span>
      </p>
    </div>
  </div>

  <!-- i18n (load once, before module script) -->
  <script src="translations.js"></script>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script type="module">
    import { initializeApp }
      from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
    import {
      getFirestore,
      collection,
      query,
      where,
      getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1056807867882",
      appId: "1:1056807867882:web:e59ddd8f6353d190080e93"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // i18n helpers
    const i18n = window.fishingLogI18n;
    const t = (key) => (i18n && typeof i18n.t === "function") ? i18n.t(key) : key;
    function reapplyTranslations() {
      if (i18n && typeof i18n.applyTranslations === "function") i18n.applyTranslations();
    }

    // Apply static page translations now
    reapplyTranslations();

    const backBtn = document.getElementById("backBtn");
    backBtn.onclick = () => {
      window.location.href = "index.html";
    };

    let map;

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }
      initMap();
      await loadSpotsAndCatches(user);
    });

    function initMap() {
      map = L.map("map").setView([59.437, 24.7536], 7);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);
    }

    function getApproxMoonPhase(date) {
      const lp = 2551443;
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14);
      const diff = date.getTime() - knownNewMoon;
      const phase = (diff / 1000) % lp;
      let frac = phase / lp;
      if (frac < 0) frac += 1;
      return frac;
    }

    function computePredictionScoreForDay(catches, temp, windMs, press, moon) {
      const usable = catches.filter(c =>
        typeof c.weatherTemp === "number" &&
        typeof c.weatherWindMs === "number" &&
        typeof c.weatherPressure === "number"
      );
      if (!usable.length) return null;

      const scores = usable.map(c => {
        let penalty = 0;

        const tempDiff = Math.abs(c.weatherTemp - temp);
        if (tempDiff > 5) penalty += (tempDiff - 5) * 2;

        const windDiff = Math.abs(c.weatherWindMs - windMs);
        if (windDiff > 4) penalty += (windDiff - 4) * 3;

        if (press < 1000) {
          if (c.weatherPressure >= 1000) penalty += 10;
        } else {
          if (c.weatherPressure < 1000) penalty += 10;
        }

        if (typeof c.moonPhase === "number") {
          const moonDiff = Math.abs(c.moonPhase - moon);
          penalty += moonDiff * 40;
        }

        let score = 100 - penalty;
        if (score < 0) score = 0;
        if (score > 100) score = 100;
        return score;
      });

      return scores.reduce((a, b) => a + b, 0) / scores.length;
    }

    function getWeatherIconAndLabel(code) {
      if (code === 0)  return { icon: "‚òÄÔ∏è", label: t("home.weatherClear") };
      if (code === 1)  return { icon: "üå§Ô∏è", label: t("home.weatherMainlyClear") };
      if (code === 2)  return { icon: "‚õÖ",  label: t("home.weatherPartlyCloudy") };
      if (code === 3)  return { icon: "‚òÅÔ∏è", label: t("home.weatherOvercast") };
      if (code >= 51 && code <= 57) return { icon: "üå¶Ô∏è", label: t("home.weatherDrizzle") };
      if (code >= 61 && code <= 67) return { icon: "üåßÔ∏è", label: t("home.weatherRain") };
      if (code >= 71 && code <= 77) return { icon: "üå®Ô∏è", label: t("home.weatherSnow") };
      if (code >= 80 && code <= 82) return { icon: "üå¶Ô∏è", label: t("home.weatherRainShowers") };
      if (code >= 85 && code <= 86) return { icon: "üå®Ô∏è", label: t("home.weatherSnowShowers") };
      if (code === 95) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstorm") };
      if (code === 96 || code === 99) return { icon: "‚õàÔ∏è", label: t("home.weatherThunderstormHail") };
      return { icon: "‚ùì", label: t("home.weatherUnknown") };
    }

    function weekdayKeyForDate(d) {
      const keys = [
        "home.weekdaySun",
        "home.weekdayMon",
        "home.weekdayTue",
        "home.weekdayWed",
        "home.weekdayThu",
        "home.weekdayFri",
        "home.weekdaySat"
      ];
      return keys[d.getDay()] || "home.weekdaySun";
    }

    function dateLabelForOffset(offset) {
      const base = new Date();
      base.setDate(base.getDate() + offset);

      const wd = t(weekdayKeyForDate(base));
      const day = base.getDate();
      const month = base.getMonth() + 1;
      const year = base.getFullYear();
      return `${wd} ${day}.${month}.${year}`;
    }

    async function loadSpotsAndCatches(user) {
      const spotsSnap = await getDocs(
        query(collection(db, "spots"), where("userId", "==", user.uid))
      );
      const spots = spotsSnap.docs.map(d => ({ id: d.id, ...d.data() }));

      const catchesSnap = await getDocs(
        query(collection(db, "catches"), where("userId", "==", user.uid))
      );
      const allCatches = catchesSnap.docs.map(d => ({ id: d.id, ...d.data() }));

      for (const spot of spots) {
        if (typeof spot.latitude !== "number" || typeof spot.longitude !== "number") continue;

        const spotCatches = allCatches.filter(c => c.spotId === spot.id);
        const { weatherNowHtml, tomorrowScore, next3 } =
          await fetchWeatherAndPrediction(spot, spotCatches);

        let color = "red";
        if (tomorrowScore == null) {
          color = "gray";
        } else if (tomorrowScore >= 70) {
          color = "green";
        } else if (tomorrowScore >= 40) {
          color = "gold";
        }

        const marker = L.circleMarker(
          [spot.latitude, spot.longitude],
          { radius: 7, color }
        ).addTo(map);

        const total = spotCatches.length;
        let biggest = 0;
        let bigSpecies = "-";
        spotCatches.forEach(c => {
          if (typeof c.weightKg === "number" && c.weightKg > biggest) {
            biggest = c.weightKg;
            bigSpecies = c.species || "-";
          }
        });

        const mapsUrl =
          `https://www.google.com/maps?q=${spot.latitude},${spot.longitude}`;

        const spotName = spot.name || t("spotAdd.unnamedPlace");

        let popupHtml = `
          <div style="min-width:260px;">
            <strong>${spotName}</strong><br/>
            <span data-i18n="home.statsTotalCatches">Total catches</span>: ${total},
            <span data-i18n="home.biggestFish">Biggest</span>: ${biggest.toFixed(2)} kg ${bigSpecies}<br/>
            ${weatherNowHtml}<br/>
            <span data-i18n="home.predictionNext3Days">Prediction (next 3 days)</span>:<br/>
        `;

        next3.forEach(p => {
          const scoreText = (p.score == null) ? t("home.na") : (p.score.toFixed(0) + "%");
          popupHtml += `${p.dateLabel}: ${scoreText}<br/>`;
        });

        popupHtml += `
            <div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:6px;">
              <button class="secondary-btn" data-open-spot="${spot.id}" data-i18n="home.openSpot">Open spot</button>
              <button class="secondary-btn" data-add-catch="${spot.id}" data-i18n="home.AddCatch">Add catch</button>
              <a class="secondary-btn" href="${mapsUrl}" target="_blank" rel="noopener noreferrer" data-i18n="home.googleMaps">Google Maps</a>
            </div>
          </div>
        `;

        marker.bindPopup(popupHtml);

        marker.on("popupopen", (e) => {
          // Translate content inside popup (added dynamically)
          reapplyTranslations();

          const popupEl = e.popup.getElement();
          if (!popupEl) return;

          const openBtn = popupEl.querySelector("button[data-open-spot]");
          const addBtn  = popupEl.querySelector("button[data-add-catch]");

          if (openBtn) {
            openBtn.onclick = () => {
              window.location.href = `spot.html?id=${encodeURIComponent(spot.id)}`;
            };
          }
          if (addBtn) {
            addBtn.onclick = () => {
              window.location.href = `add-catch.html?spotId=${encodeURIComponent(spot.id)}`;
            };
          }
        });
      }

      // Safety: re-apply after markers created
      reapplyTranslations();
    }

    async function fetchWeatherAndPrediction(spot, spotCatches) {
      const lat = spot.latitude;
      const lng = spot.longitude;

      // Default (translated)
      let weatherNowHtml =
        `<span data-i18n="home.weatherNow">Weather now</span>: ${t("home.failedToLoad")}`;

      let tomorrowScore = null;
      const next3 = [];

      try {
        const url =
          `https://api.open-meteo.com/v1/forecast` +
          `?latitude=${lat}&longitude=${lng}` +
          `&current=temperature_2m,wind_speed_10m,weather_code` +
          `&hourly=temperature_2m,wind_speed_10m,pressure_msl` +
          `&forecast_days=4&wind_speed_unit=ms&timezone=auto`;

        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        const cur = data.current || {};
        const ct  = cur.temperature_2m;
        const cw  = cur.wind_speed_10m;
        const cc  = cur.weather_code;

        const { icon, label } = getWeatherIconAndLabel(cc);
        const parts = [];
        if (label) parts.push(label);
        if (typeof ct === "number") parts.push(`${ct.toFixed(1)} ${t("home.unitCelsius")}`);
        if (typeof cw === "number") parts.push(`${t("home.wind")} ${cw.toFixed(1)} ${t("home.unitMetersPerSecond")}`);

        weatherNowHtml =
          `<span data-i18n="home.weatherNow">Weather now</span>: ${icon} ${parts.join(", ")}`;

        const hourly = data.hourly || {};
        const times  = hourly.time || [];
        const temps  = hourly.temperature_2m || [];
        const winds  = hourly.wind_speed_10m || [];
        const presses = hourly.pressure_msl || [];

        function getForecastForOffset(offset) {
          const base = new Date();
          base.setDate(base.getDate() + offset);
          const yyyy = base.getFullYear();
          const mm = String(base.getMonth() + 1).padStart(2, "0");
          const dd = String(base.getDate()).padStart(2, "0");
          const dateStr = `${yyyy}-${mm}-${dd}`;

          let idx = times.findIndex(t => t.startsWith(`${dateStr}T12`));
          if (idx === -1) idx = times.findIndex(t => t.startsWith(dateStr));
          if (idx === -1) return null;

          const fTemp  = temps[idx];
          const fWind  = winds[idx];
          const fPress = presses[idx];
          const fMoon  = getApproxMoonPhase(base);
          return { temp: fTemp, wind: fWind, press: fPress, moon: fMoon };
        }

        for (let offset = 1; offset <= 3; offset++) {
          const fc = getForecastForOffset(offset);
          if (!fc) {
            next3.push({ dateLabel: dateLabelForOffset(offset), score: null });
            continue;
          }

          const score = computePredictionScoreForDay(
            spotCatches,
            fc.temp,
            fc.wind,
            fc.press,
            fc.moon
          );

          if (offset === 1) tomorrowScore = score;
          next3.push({ dateLabel: dateLabelForOffset(offset), score });
        }
      } catch {
        // keep defaults
      }

      return { weatherNowHtml, tomorrowScore, next3 };
    }
  </script>

  <!-- Add these NEW keys to translations.js (see below) -->
</body>
</html>
